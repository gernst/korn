\documentclass{llncs}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.8]{beramono}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{mathtools}
\usepackage{tabto}
\usepackage{comment}
\usepackage{xspace}
\usepackage{todonotes}

\usepackage{hyperref}
\hypersetup{allcolors=blue,colorlinks=true}

\usepackage{cleveref}
% \usepackage[numbers,sort&compress]{natbib}
\newcommand{\mailto}[1]{\href{mailto:#1}{\ttfamily #1}}

\newcommand{\Korn}{\textsc{Korn}\xspace}
\newcommand{\err}{\lightning}
\newcommand{\brk}[1]{{#1}_\downarrow}
\newcommand{\False}{\mathit{false}}
\newcommand{\True}{\mathit{true}}

\author{Gidon Ernst\thanks{Jury Member}}
\title{\Korn---Software Verification with Horn clauses \\ (Competition Contribution)}
\institute{LMU Munich \\ \mailto{gidon.ernst@lmu.de}}
\pagestyle{plain}

\begin{document}

\maketitle

\begin{abstract}
    \Korn is a software verifier that infers correctness certificates automatically using state-of-the-art Horn-clause solvers, such as Z3 and Eldarica,
    which are used in a portfolio together with cheap random sampling.
    The tool is available at \url{https://github.com/gernst/korn}.

    % {\color{red} With the intention to be published as competition contribution.}
    \keywords{Software Verification \and Horn clauses \and Loop Contracts}
\end{abstract}

\section{Verification Approach}
\label{sec:approach}

\Korn is a verifier for C programs that is based on a translation into systems of Horn clauses
\cite{bjorner2015horn,gurfinkel2019science}.
Therein, each program location is abstracted by a second-order predicate
over the program variables which are active at that point.
The system of Horn clauses has a (second-order) solution if and only if the program is correct.
Horn clauses are an attractive encoding that is linear in the size of the program.
Moreover, Horn clauses are inherently modular,
such that loops, procedure contracts (cf. discussion of category \texttt{Recursive})), and non-local control flow like \texttt{goto}s and labels can be easily abstracted.
As usual, loops are verified by invariants, which need to hold in the states
encountered throughout the execution of a loop.
\Korn is therefore similar to SeaHorn~\cite{gurfinkel2015seahorn} but it operates on the C source level instead of LLVM.
While similarly being based on Horn clause translations,
\Korn aims at a rather different design point, namely to favor simplicity over features, therefore offering a good platform for experiments.
Eldarica has its own C frontend that supports a different set of features,
recently published as \textsc{TriCera}~\cite{esen2022tricera}.
Here the main distinction is that \Korn uses a large block encoding,
such that the generated verification tasks are very close to the structure of the input program.

\Korn additionally supports a second verification approach in terms of loop contracts~\cite{hehner1999refinement,tuerk2010local,hehner2005specified,ernst:vmcai2022}.
This was the original motivation to develop the tool, and neither
SeaHorn nor \textsc{TriCera} support this feature,
albeit it was not used for SV-COMP because
it offers no advantages~\cite{ernst:arxiv2020:summaries}
and the witness format does not support this approach because it lacks quantifiers.

\Korn uses state-of-the-art solvers to determine the satisfiability of the generated Horn clause system (cf. \cref{sec:architecture}),
specifically for SV-COMP Z3~\cite{bjorner2013solving} and Eldarica~\cite{hojjat2018eldarica}.
Both solvers generate evidence for correctness of a given program in terms of models that describe how the unknown predicates need to be instantiated.
Moreover, Eldarica can generate counterexample traces, and \Korn instruments the Horn clause system to get
the concrete values returned by the \texttt{\_\_VERIFIER\_nondet\_*()} functions on an error path.
These solvers have different strengths and weaknesses.
To that end, \Korn implements a portfolio approach with several sequential stages.
The configuration for SV-COMP is as follows:
\begin{enumerate}
    \item Initially, 10s of random sampling with small values is performed.
          It picks for each input value uniformly between number 0, and values of 2, 5, and 10 bits respectively, possibly with a sign.
          This turned out to be enormeously effective,
          finding all 210 violations that \Korn reported, most in under 2 seconds
          (cf. \cref{sec:discussion}).
          There is no particular justification for the concrete sampling scheme,
          except that it seems to work fine on the competition benchmarks.
          Choosing 0 always solves 57 tasks only as evidence that some variation is beneficial,
          and absense of too large values avoids very long running loops
          when the counter is nondeterministic.

    \item Next, Z3 is executed on the verification problem, translated from C to Horn clauses for 20s. Usually, Z3 finds solutions very quickly if it succeeds at all,
          specifically on those benchmarks where Z3 succeeds but not Eldarica.
    \item Finally, Eldarica is executed for the remaining time.
          From past experience, it should be slightly better in comparison to Z3 in the long run on this specific set of tasks~\cite{ernst:arxiv2020:summaries}.
    The generated invariants from Eldarica tend to be simpler and avoid the existential quantifiers
    often introduced by Z3, which improves witness generation.
    To prevent spurious counterexamples,
    \Korn reports a violation of the specification only if it can be confirmed by executing the program natively.
\end{enumerate}
However, unfortunately, due to some unknown issue, during the 2023 competition,
no result was generated by the Eldarica configuration at all;
whereas in 2022 it was converse due to a parsing problem of Z3 models.
We re-ran the evaluation, correct and up-to-date results are presented and compared in \cref{sec:discussion}.
The specific timeouts for the individual tools
are chosen heuristically from past experience.


\section{Software Architecture}
\label{sec:architecture}

\Korn is mainly written in the JVM language Scala
    \footnote{\url{https://scala-lang.org}}.
The front-end uses a custom parser, generated with jFlex and Beaver.
The random sampler relies on native execution which links
the benchmark task with a C file \verb!__VERIFIER_random.c!
that implements the \verb!_VERIFIER_nondet_*! functions.
Verification conditions are generated in the fragment of SMT-LIB of the \texttt{HORN} logic.%
    \footnote{\url{https://chc-comp.github.io/format.html}}
\Korn can invoke any compliant solver as a backend either using its standard input or a file to communicate the verification task.
There is explicit support for Z3~\cite{gurfinkel2019science}, Eldarica~\cite{hojjat2018eldarica}, and recently also for Golem~\cite{blicha2022split}%
    \footnote{Golem performs fairly similar to Z3 but was not as mature at the time.}
to pass e.g. timeouts with tool-specific options or to produce models resp. counterexamples.
Currently, \Korn makes use of the theory of integers 
and the theory of arrays.

In order to produce SV-COMP correctness witnesses, \Korn can read the models generated by the backend-solvers, and translate them back into C expressions.
The correctness witnesses produced currently are derived from
the invariants that are reported back by the Horn solvers (\texttt{get-model} resp. \texttt{-ssol} flag of Eldarica).
Violation witnesses are either read off the output of Eldarica (\texttt{-cex} flag),
or from the output of the random sampler, as a sequence of nondeterministic choices.
When a counterexample is found, a test harness is compiled confirm whether \texttt{reach\_error()} is in fact called.

\section{Discussion: Strengths and Weaknesses}
\label{sec:discussion}

\Korn supports a substantial fraction of the C~language, with the greatest limitation
being the lack of support for dynamic data structures (see website for a detailed account).
% That said, the implementation is staight-forward and modular in the specifics of the translation
% to clauses, so that \Korn is a nice basis for experiments.
The translation supports most control structures, including \texttt{goto} and labels.
\Korn is lation su

\Korn inherits most of the strenths and limitations of the underlying solvers.
Tasks that require invariants or procedure contracts in the fragment of linear integer arithmetic
are typically proved quickly by the solvers.
However, as soon as arrays are involved, the solvers typically perform badly,
as can be seen on many tasks in category \texttt{Loops}.
Still, some loop invariants can be found over arrays.
\Korn never unrolls any loop explicitly (albeit the solvers may do so internally),
it may not perform well on
tasks with a fixed loop bound and which can be solved efficiently by exploration of the state space.
Currently, any task which requires a memory model is out of scope.

The random sampler is a key success factor for \Korn in the competition.
It quickly find many errors, including one in \texttt{nla-digbench/geo1-u.c} caused by an unsigned integer overflow.
This masks an unsound verdict by \Korn, which does not model overflow arithmetic currently, and therefore deems the program safe.
Having ground truth to confirm counterexamples by native execution conversely prevents a few false results.
% An example is \texttt{recursive/Primes.c}, which for unknown reasons
% currently produces a spurious counterexample (possibly because it requires a \emph{recursive} predicate in the model).
% 
\Korn employs a trick similar to~\cite{monniaux2016cell} but less sophisticated
to reduce the need for quantifiers in invariants over arrays.
It targets the pattern typically used as means to specify property $P$ over individual array elements $a[k]$,
occurring after a loop:
\verb|int k; if(0 <= k && k < n) assert(P(a[k]));|
The idea is to lift all local variables like $k$ to the top-level of the procedure,
such that the invariant only needs to regard this specific value of $k$, not all of them.
The benefit of this encoding has been observed in a few instances,
but as it cannot be turned off entirely, the overall impact is not entirely clear.
Note that presence of such a $k$ in the invariant is not actually syntactically correct,
but fortunately it does not seem to happen often in the competition.
Finally, the current parser is somewhat limited and fails on some portion of tasks,
notably in \texttt{ControlFlow} and other categories where \Korn does not participate in.


For further experiments on random sampling should
take into account the actual violation traces produced by the Horn backends.

\section{Tool Setup and Configuration}
\label{sec:project}

The implementation of \Korn is available at
    \url{https://github.com/gernst/korn} under the MIT license,
the version running in SV-COMP 2023 was packaged from commit
\href{https://github.com/gernst/korn/commit/8e968dd9e1498d358270d1e78d473befca8e63a8}{\tt 8e63a8}
and shows version number \texttt{0.4}.

\Korn can be downloaded and installed from the repository, type \texttt{make} to compile,
more detailed instructions can be found in the \texttt{README.md}.
All dependencies, except for Java~11 and \texttt{gcc}, are included or will be downloaded automatically.
After compilation, you can run \texttt{./korn.sh} or \texttt{./run}
(where the latter includes the current directory \texttt{.} in \texttt{PATH}).
A pre-built, ready-to-run
\href{https://gitlab.com/gernst/svcomp-archives-2023/-/blob/master/2023/korn.zip}{archive}
is with the competition version is available in the official repository.

\smallskip

\textbf{Participation.} In 2023, \Korn participated in four categories
\texttt{ControlFlow},
\texttt{Loops},
\texttt{Recursive},
\texttt{XCSP}
for property \texttt{ReachSafety}.


\smallskip
\textbf{Configuration.}
\Korn ran with the following options
(which are spelled out in their long form in the benchmark \texttt{xml} file).

\texttt{-i} (implicit)
    \tabto{2.8cm} generate verification conditions with invariants only

\texttt{-w}
    \tabto{2.8cm} write SMT-LIB file to disk (required for Eldarica)

\smallskip

\texttt{-model} 
    \tabto{4.8cm} produce model

\texttt{-witness witness.graphml}
    \tabto{4.8cm} write SV-COMP witness

\texttt{-smt2 clauses.smt2}
    \tabto{4.8cm} write verification task

\texttt{-confirm} 
    \tabto{4.8cm} confirm violation witnesses by execution

\smallskip

\texttt{-r~~10}
    \tabto{4.8cm} Run random sampling for 10s

\texttt{-t~~20 -z3}
    \tabto{4.8cm} Try Z3 4.11.12 subsequently for 20s

\texttt{-t~900 -eld:portfolio}
    \tabto{4.8cm} Run Eldarica 2.0.8 for the remaining time
    \tabto{4.8cm} with its \texttt{-portfolio} option

\smallskip

\noindent
The arguments to the backend solver are shown in the command line output.

\smallskip

\textbf{Contributors \& Acknowledgement.}
\Korn is developed and maintained by the author.
The source code is available via \url{https://github.com/gernst/korn} under the MIT license.
Gregor Alexandru~\cite{alexandru2019} and Johannes Blau have contributed
key insights to approach of loop contracts~\cite{ernst:vmcai2022}.

\bibliographystyle{splncs04}
\bibliography{korn.bib}

\end{document}
