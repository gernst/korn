package korn;

import java.util.Set;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "Parser.grammar".
 */
public class Parser extends beaver.Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short INCR = 1;
		static public final short DECR = 2;
		static public final short STAR = 3;
		static public final short PLUS = 4;
		static public final short MINUS = 5;
		static public final short AMP = 6;
		static public final short ID = 7;
		static public final short LPAREN = 8;
		static public final short NUM = 9;
		static public final short SIZEOF = 10;
		static public final short PREFIX = 11;
		static public final short POSTFIX = 12;
		static public final short STRING = 13;
		static public final short BANG = 14;
		static public final short TILDE = 15;
		static public final short LBRACK = 16;
		static public final short ARROW = 17;
		static public final short DOT = 18;
		static public final short SEMICOLON = 19;
		static public final short DIV = 20;
		static public final short MOD = 21;
		static public final short SHL = 22;
		static public final short SHR = 23;
		static public final short LT = 24;
		static public final short LE = 25;
		static public final short GE = 26;
		static public final short GT = 27;
		static public final short COMMA = 28;
		static public final short EQ = 29;
		static public final short NEQ = 30;
		static public final short STRUCT = 31;
		static public final short LBRACE = 32;
		static public final short UNION = 33;
		static public final short ENUM = 34;
		static public final short UNSIGNED = 35;
		static public final short CARET = 36;
		static public final short VOID = 37;
		static public final short BOOL = 38;
		static public final short FLOAT = 39;
		static public final short DOUBLE = 40;
		static public final short SIGNED = 41;
		static public final short TYPE = 42;
		static public final short PIPE = 43;
		static public final short AND = 44;
		static public final short ASG = 45;
		static public final short QUESTION = 46;
		static public final short OR = 47;
		static public final short ASG_OP = 48;
		static public final short RBRACE = 49;
		static public final short RPAREN = 50;
		static public final short WHILE = 51;
		static public final short DO = 52;
		static public final short FOR = 53;
		static public final short IF = 54;
		static public final short TYPEDEF = 55;
		static public final short GOTO = 56;
		static public final short CASE = 57;
		static public final short SWITCH = 58;
		static public final short RETURN = 59;
		static public final short BREAK = 60;
		static public final short CONTINUE = 61;
		static public final short COLON = 62;
		static public final short RBRACK = 63;
		static public final short CHAR = 64;
		static public final short SHORT = 65;
		static public final short INT = 66;
		static public final short LONG = 67;
		static public final short LONGLONG = 68;
		static public final short ELSE = 69;

		static public final String[] NAMES = {
			"EOF",
			"INCR",
			"DECR",
			"STAR",
			"PLUS",
			"MINUS",
			"AMP",
			"ID",
			"LPAREN",
			"NUM",
			"SIZEOF",
			"PREFIX",
			"POSTFIX",
			"STRING",
			"BANG",
			"TILDE",
			"LBRACK",
			"ARROW",
			"DOT",
			"SEMICOLON",
			"DIV",
			"MOD",
			"SHL",
			"SHR",
			"LT",
			"LE",
			"GE",
			"GT",
			"COMMA",
			"EQ",
			"NEQ",
			"STRUCT",
			"LBRACE",
			"UNION",
			"ENUM",
			"UNSIGNED",
			"CARET",
			"VOID",
			"BOOL",
			"FLOAT",
			"DOUBLE",
			"SIGNED",
			"TYPE",
			"PIPE",
			"AND",
			"ASG",
			"QUESTION",
			"OR",
			"ASG_OP",
			"RBRACE",
			"RPAREN",
			"WHILE",
			"DO",
			"FOR",
			"IF",
			"TYPEDEF",
			"GOTO",
			"CASE",
			"SWITCH",
			"RETURN",
			"BREAK",
			"CONTINUE",
			"COLON",
			"RBRACK",
			"CHAR",
			"SHORT",
			"INT",
			"LONG",
			"LONGLONG",
			"ELSE"
		};
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjMdby54KQVJqzavbmI6GmU8J39Q2ou08g7YYWQ00JRkIA6D3LNNSL4HKL4E85614GF51" +
		"1KF1MF50G42#ym1C5BnH5H44yKBnHQrzNVvEfdfcUIIRk7$v#wVo#VbNrrVTULNLrLVK0a3" +
		"jEVO1fc8uvc8bPk1bluzyu7sDn1lw52t0TRa04UMY2Lp41bo4VJL4FzR476k1g52Y5kx06Y" +
		"$4OyjKsquFNy3JZSX12CohKmPVu5ZzZAy9u0s$XOxoB3x19VPX1Ut$CCxJFzIZKDRG$ztZs" +
		"H4D4qGXxuKpybwr8gPr1#IprcQ5yYQ#ojzUDiJVsmRxO3nFPjuEoKhuOznZAvtZux$LLNeG" +
		"xSHiMuEzeZLOuC2lbT$2GeJpPm$zm6kMhHFbPj47Rh9GxO9cX$AA7$$6uCZ7L7FiKut1Hbi" +
		"$vK7Gqb2$tyCypb7zBgRmTL#18TCfAkIvQakDLvEAEIhvNK6ZbCNM0eNoCHpc806ohWLLFN" +
		"M3jZIxPA5lryBmLe79CTGUVsx4OWt#W7OumbBjvb0z3Unp2LX#5ep4toxcz6x$Z14Dv9rN7" +
		"f53kdaAvGYihNEcZx79qHbVqHqyKusvZL2k4OxdcE0x7emWzS29Ay4$qHb#EwbhOQCQvF53" +
		"FvVcQxK4CmX2CmCaOXbCz$2vRZFyx72mb4ttufQO5ylT27$JJR4khnc$LnU5IyeGF$ppBOi" +
		"q1xET0$CetTvLccvo1VmnMM7jmbf#29wNa3n$#kbOTd6GrmZFaDtbC$i7u3sU7vh52FZn3K" +
		"OhXACF8D3odOJnEb$QyxiDpDjV5ypI3Fu$BuDut#l1SY79ChGRFL1#UARW6Ct0jPgVXcOSj" +
		"k5x69#p3SoDkmYrOoBzqFDjmk$3a#l2qnGEu7qlmQ1gUgVW6ApFqQpMUmdDu2UlIyBo97ok" +
		"VUyCadZQQvsMinuPgZFFxIJmVQfwFi1cVL8FdioIUppNF5$WANrU3PrSIp$UQvmVyX5#gpf" +
		"FyNbX1pTC6RQpyQhG7IUs1ve6LOqMOZgrZt9Cjc##voMEkqAEILkZqtYRMNh9JmhD2EzSQx" +
		"gD8wQsHeW#dEKgBwDEzjVQ4UsKO9LvEF5ACDlGenUBJyyHZK$6OiTdo9FObSx#SCqLYlov5" +
		"2vRz3SqHktnuh7qIshE8iySTsMYcM6b3#gSPPqvr#J4xVKgCZFLfaX5vQr9aJMQUUxsNeTR" +
		"e6cdKUckzjTvQxr$5cxWAU$E9wtTYlcRHVYS1xWxwczdT#rxmx0xtLQOUiHh7jXchldDplg" +
		"FvtHVYzriO4Nw5r#4fDiRRdVj7CqInFoDRqDyIhVXDVY2$UbipjXbtKjVJtkCfqd4zkVCqf" +
		"oVArX$ANdJarziHE9BzwCIU79DHkprvujeb7WNRLxihl#2FunVxyTAArDhfbJkGqw$NLL5s" +
		"UXtEKZbgA4Sy$CrzbOjvKkl5KqSVdZlAcCv6kRD7kQ3AokqhbVCuujaeXptAKL$bvZvpBFl" +
		"d7FRCi702Vrovn7Ts5sNPPrjpH7NVutpzTAh0K2xoA9VoJ3uSGtaU7i6JTNRAWrWonAFgFB" +
		"S2YV9JpjE$9Tlwj#GEMSxjg5OrbGlqNrMK1uZou2eeEyyaRAWC48x1cYFV#6swW6jfKndLv" +
		"fpBXJAN7ROmlncTNt4FrgkpoU#onVcxI4bp7$vupKBTjgB$2tyH#rd8cLh0VZfi1Hdu2$Zc" +
		"5Z2gCz4jAV7XjpdkHVgf5tfuJ7x7RmjFsBUTiR$qF4N24$NbYSWO#lEu3Ebv8dgLhZgFNxy" +
		"6LBDVVkFiSZWxU7gUuemyKVRCsNVzUS9wfqdVhxRwNUsPzhb7qpxtFCtJdkj0vsgCSr4IJr" +
		"JpHAlvt2D9F4MQvuHgyXoIn1Ef7ET8ZURF8CtZFF6ULUTHAf679UJXdIiix$5rhAzUN$tMW" +
		"UGLEhstSgUaXh52ArxEFirx2c$D5Al0MKoVz5RfAzCe4HdFUz9eiymPfLXyMXuZDXMF6Pib" +
		"Jr9VClUB#q1Il$gXFyi6uYIbqe#Fl6Nns6BE7S$8LcDCqZvhbUBoRPMpjoL4UliaxqQNfCW" +
		"Qp3pHYMOyhTTaTjTwQxsrtbhlNyuhgwCddxH#9#Ph5krt4d1s1tVNSr8TlBk3aHfQkS#S0b" +
		"Zxbhi$W7McDPKqoiNeRqbRxlo#LMwKbtlgu22VyZFInEGvo4Ri8ZIHib9QUpSTQ4JTnKpSA" +
		"Ut8ZyVcjAB$D2#VrKdm8XT3NLXdjjIVmNG5SJvn1P6yWI#8guX1uYl4OuaR6JUNI5$eQU8l" +
		"GEvUG3X2R49iJ3oKIFtSeuc7iGujV3onFt40aNN3fpAU7E5pYIyGsOpGxKIs8pIHU2lrLXC" +
		"VO7uOyGaW62M#J3oS#3wnDDwtu4#ilql6Q2ZzszsqxUYTBVtUnlAVMNTIFCuUI$uS9cwGV6" +
		"FXk5fm5Cjw6sCuIUfTpDjEuepKpouIfkzaOZwHHH7EaI379K8B3Y5s8quWSao22uWZYSyHH" +
		"xCzuwHF2ncxt6Zh2k6UvDKAdCxRKcdlVQotalQk#2Rp5XiNzj$cEDeRnRUK$Madt3ym$ofn" +
		"X#HtCx#E#9la6x3kTyJDr9$Ejht8vyldQdMCjmFZMMvvssRBd0lMfTMNT6kM$oWnBxgOCq7" +
		"gbqcTheBT1FjGTnxzbpFpk9ITmRBxMNONCsn$q6bF1$6THvyp3fmlrZbkcSMwmJBQRFhMql" +
		"SDqzEa$XoEUplskGLzxn4BYHolWFDkn#OIVS7rj0SbvX7MuRmBRk1OS0u5E3Q1LiPpsSBOK" +
		"wLkCy4bBeQ2td4AxOgdhGcnDD$zhKPwZHdpPnlRiC2RjyQwY0h1cO9pudMmEJElTPIH7YPO" +
		"AYZSrXp1LO8oBwplN0m41Gi5MmgE4JnFy7p1#OAl2MuIt2duhM2CNzwHmFSksW71eBSlED2" +
		"RjniPlboZFD#i9tqfI2oB#tBgf2uFMCBN9xNV7YvuYg2yF$O8mT62vOAN2bwMeDF9u9mXkC" +
		"Y$lRdxfF4rzVS5cYNaPtlprfMyRH3zjSAt7zCl6J47#F5dChv$mIhKQIXjQMoKoPvh3HHSP" +
		"lWwIfdCdS1WmpSanHZCbVhT9I$hUk0iALyeiMSASa#sHxbfUvRKdUBbjEIvXl85Lqli#DHz" +
		"jFRbYiBzNcrK5MgJUjz9C$UUcg2cgslKD7KrSrFL53LPNQckK9UgozLbgbnDKXFL9VICrx4" +
		"NEHngkoQ4#bBjLb#hdtNw3$MmUeZu86snBk4#hXRHkASfxlFgDje26lkckDShhksAvmfr2#" +
		"rcsaqqhidgHjeDjEjfrz5cYzeishMqcRGPwWcrKhTeXVOzgdWQKqjrUhDwN2sJlYwXSSrMu" +
		"tJkGiNpXxfO#BQehMgi#bHTnJJt2SLzLDrBkuTsDurxZBgJTeTwJ7t2dlwaVb6$gjzOyhlQ" +
		"eRxIO$AkZE86hV6EvDOxAkfjqNbJtyUgjtZVhRYZgczrQzQfDpH#h3vIF6kfbtMzjVg#HYr" +
		"NBn6vvogUbTJpjEU4hqAjhamzItkcClUqgo$vfzmngCnNg2SbzOtQRPIkKZirxcBhVgHnNr" +
		"MlgzVKzqIU3r214JoB5$CitelOYwVotd3#1vEb$nsahpQR9x00pURfsQBP6CJy80GnXFaXp" +
		"0zZlepfCgRxqVeptPzb0#7y7ooB9t0B0sY3jTae8POGUz9AcIvbtU6iEvpfasadQWlIRCDo" +
		"n486XenoM#82Hap0oCVIiRYmWRcqElftOTTi8ntB1nCi86OR$a06i$ya2tdotTb6qtfmB7l" +
		"eT22D9VfJrGzMsiZ$0Qr2nuy=");

	static final Action RETURN2 = new Action() {
		public Symbol reduce(Symbol[] _symbols, int offset) {
			return _symbols[offset + 2];
		}
	};

    Set<String> types;
    Symbol s(Object x) { return new Symbol(x); }

	private final Action[] actions;

	public Parser() {
		super(PARSING_TABLES);
		actions = new Action[] {
			new Action() {	// [0] unit = stmts.ss
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ss = _symbols[offset + 1];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Stmt[] ss = _list_ss == null ? new Stmt[0] : (Stmt[]) _list_ss.toArray(new Stmt[_list_ss.size()]);
					 return s(new Block(ss));
				}
			},
			RETURN2,	// [1] bound = LBRACK expr.e RBRACK
			new Action() {	// [2] lst$bound = bound
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [3] lst$bound = lst$bound bound
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [4] opt$lst$bound = 
			Action.RETURN,	// [5] opt$lst$bound = lst$bound
			Action.RETURN,	// [6] bounds = opt$lst$bound
			new Action() {	// [7] dims = bounds.bs
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_bs = _symbols[offset + 1];
					final ArrayList _list_bs = (ArrayList) _symbol_bs.value;
					final Expr[] bs = _list_bs == null ? new Expr[0] : (Expr[]) _list_bs.toArray(new Expr[_list_bs.size()]);
					 return s(new Dims(false, bs));
				}
			},
			new Action() {	// [8] dims = LBRACK RBRACK bounds.bs
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_bs = _symbols[offset + 3];
					final ArrayList _list_bs = (ArrayList) _symbol_bs.value;
					final Expr[] bs = _list_bs == null ? new Expr[0] : (Expr[]) _list_bs.toArray(new Expr[_list_bs.size()]);
					 return s(new Dims(true, bs));
				}
			},
			new Action() {	// [9] param = type.t dims.ds
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_ds = _symbols[offset + 2];
					final Dims ds = (Dims) _symbol_ds.value;
					 return s(new ParamSpec(t, ds));
				}
			},
			new Action() {	// [10] param = type.t ID.n dims.ds
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ds = _symbols[offset + 3];
					final Dims ds = (Dims) _symbol_ds.value;
					 return s(new ParamSpec(t, n, ds));
				}
			},
			new Action() {	// [11] params = param
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [12] params = params COMMA param
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [13] var = ID.n dims.ds
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ds = _symbols[offset + 2];
					final Dims ds = (Dims) _symbol_ds.value;
					 return s(new VarSpec(n, ds));
				}
			},
			new Action() {	// [14] var = ID.n dims.ds ASG expr.i
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ds = _symbols[offset + 2];
					final Dims ds = (Dims) _symbol_ds.value;
					final Symbol _symbol_i = _symbols[offset + 4];
					final Expr i = (Expr) _symbol_i.value;
					 return s(new VarSpec(n, ds, i));
				}
			},
			new Action() {	// [15] vars = var
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [16] vars = vars COMMA var
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [17] field = ID.n dims.ds
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ds = _symbols[offset + 2];
					final Dims ds = (Dims) _symbol_ds.value;
					 return s(new FieldSpec(n, ds));
				}
			},
			new Action() {	// [18] fields_ = field
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [19] fields_ = fields_ COMMA field
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [20] fields__ = type.t fields_.fs SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_fs = _symbols[offset + 2];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final FieldSpec[] fs = _list_fs == null ? new FieldSpec[0] : (FieldSpec[]) _list_fs.toArray(new FieldSpec[_list_fs.size()]);
					 return s(new FieldsSpec(t, fs));
				}
			},
			new Action() {	// [21] lst$fields__ = fields__
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [22] lst$fields__ = lst$fields__ fields__
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [23] opt$lst$fields__ = 
			Action.RETURN,	// [24] opt$lst$fields__ = lst$fields__
			Action.RETURN,	// [25] fields = opt$lst$fields__
			Action.RETURN,	// [26] const = ID.n
			new Action() {	// [27] consts = const
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [28] consts = consts COMMA const
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [29] exprs = expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [30] exprs = exprs COMMA expr
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 3].value); return _symbols[offset + 1];
				}
			},
			new Action() {	// [31] block = LBRACE stmts.ss RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_ss = _symbols[offset + 2];
					final ArrayList _list_ss = (ArrayList) _symbol_ss.value;
					final Stmt[] ss = _list_ss == null ? new Stmt[0] : (Stmt[]) _list_ss.toArray(new Stmt[_list_ss.size()]);
					 return s(new Block(ss));
				}
			},
			new Action() {	// [32] lst$stmt = stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					ArrayList lst = new ArrayList(); lst.add(_symbols[offset + 1].value); return new Symbol(lst);
				}
			},
			new Action() {	// [33] lst$stmt = lst$stmt stmt
				public Symbol reduce(Symbol[] _symbols, int offset) {
					((ArrayList) _symbols[offset + 1].value).add(_symbols[offset + 2].value); return _symbols[offset + 1];
				}
			},
			Action.NONE,  	// [34] opt$lst$stmt = 
			Action.RETURN,	// [35] opt$lst$stmt = lst$stmt
			Action.RETURN,	// [36] stmts = opt$lst$stmt
			Action.RETURN,	// [37] stmt = block
			new Action() {	// [38] stmt = TYPEDEF type.t ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 3];
					final String n = (String) _symbol_n.value;
					 types.add(n);
                                                           return s(new TypeDef(t, n));
				}
			},
			new Action() {	// [39] stmt = STRUCT ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return s(new StructDecl(n));
				}
			},
			new Action() {	// [40] stmt = UNION ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return s(new UnionDecl(n));
				}
			},
			new Action() {	// [41] stmt = ENUM ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return s(new EnumDecl(n));
				}
			},
			new Action() {	// [42] stmt = STRUCT ID.n LBRACE fields.fs RBRACE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_fs = _symbols[offset + 4];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final FieldsSpec[] fs = _list_fs == null ? new FieldsSpec[0] : (FieldsSpec[]) _list_fs.toArray(new FieldsSpec[_list_fs.size()]);
					 return s(new StructDef(n, Parsing.fields(fs)));
				}
			},
			new Action() {	// [43] stmt = UNION ID.n LBRACE fields.fs RBRACE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_fs = _symbols[offset + 4];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final FieldsSpec[] fs = _list_fs == null ? new FieldsSpec[0] : (FieldsSpec[]) _list_fs.toArray(new FieldsSpec[_list_fs.size()]);
					 return s(new UnionDef(n, Parsing.fields(fs)));
				}
			},
			new Action() {	// [44] stmt = ENUM LBRACE consts.cs RBRACE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cs = _symbols[offset + 3];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return s(new EnumDef(cs));
				}
			},
			new Action() {	// [45] stmt = ENUM ID.n LBRACE consts.cs RBRACE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_cs = _symbols[offset + 4];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return s(new EnumDef(n, cs));
				}
			},
			new Action() {	// [46] stmt = type.t ID.n LPAREN RPAREN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return s(new FunDecl(t, n));
				}
			},
			new Action() {	// [47] stmt = type.t ID.n LPAREN RPAREN block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Block b = (Block) _symbol_b.value;
					 return s(new FunDef(t, n, b));
				}
			},
			new Action() {	// [48] stmt = type.t ID.n LPAREN params.ps RPAREN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ps = _symbols[offset + 4];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final ParamSpec[] ps = _list_ps == null ? new ParamSpec[0] : (ParamSpec[]) _list_ps.toArray(new ParamSpec[_list_ps.size()]);
					 return s(new FunDecl(t, n, Parsing.params(ps)));
				}
			},
			new Action() {	// [49] stmt = type.t ID.n LPAREN params.ps RPAREN block.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_ps = _symbols[offset + 4];
					final ArrayList _list_ps = (ArrayList) _symbol_ps.value;
					final ParamSpec[] ps = _list_ps == null ? new ParamSpec[0] : (ParamSpec[]) _list_ps.toArray(new ParamSpec[_list_ps.size()]);
					final Symbol _symbol_b = _symbols[offset + 6];
					final Block b = (Block) _symbol_b.value;
					 return s(new FunDef(t, n, Parsing.formals(ps), b));
				}
			},
			new Action() {	// [50] stmt = type.t vars.vs SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_vs = _symbols[offset + 2];
					final ArrayList _list_vs = (ArrayList) _symbol_vs.value;
					final VarSpec[] vs = _list_vs == null ? new VarSpec[0] : (VarSpec[]) _list_vs.toArray(new VarSpec[_list_vs.size()]);
					 return s(new Group(Parsing.vars(t, vs)));
				}
			},
			new Action() {	// [51] stmt = SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Atomic.none());
				}
			},
			new Action() {	// [52] stmt = expr.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new Atomic(a));
				}
			},
			new Action() {	// [53] stmt = GOTO ID.n SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final String n = (String) _symbol_n.value;
					 return s(new Goto(n));
				}
			},
			new Action() {	// [54] stmt = CASE NUM.n COLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 2];
					final Integer n = (Integer) _symbol_n.value;
					 return s(new Case(n));
				}
			},
			new Action() {	// [55] stmt = ID.n COLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return s(new Label(n));
				}
			},
			new Action() {	// [56] stmt = RETURN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Return.none());
				}
			},
			new Action() {	// [57] stmt = RETURN expr.a SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new Return(a));
				}
			},
			new Action() {	// [58] stmt = BREAK SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Break.self());
				}
			},
			new Action() {	// [59] stmt = CONTINUE SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Continue.self());
				}
			},
			new Action() {	// [60] stmt = SWITCH LPAREN expr.e RPAREN stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Stmt b = (Stmt) _symbol_b.value;
					 return s(new Switch(e, b));
				}
			},
			new Action() {	// [61] stmt = IF LPAREN expr.a RPAREN stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Stmt b = (Stmt) _symbol_b.value;
					 return s(new If(a, b));
				}
			},
			new Action() {	// [62] stmt = IF LPAREN expr.a RPAREN stmt.b ELSE stmt.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Stmt b = (Stmt) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 7];
					final Stmt c = (Stmt) _symbol_c.value;
					 return s(new If(a, b, c));
				}
			},
			new Action() {	// [63] stmt = WHILE LPAREN expr.a RPAREN stmt.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 5];
					final Stmt b = (Stmt) _symbol_b.value;
					 return s(new While(a, b));
				}
			},
			new Action() {	// [64] stmt = DO stmt.b WHILE LPAREN expr.a RPAREN SEMICOLON
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_b = _symbols[offset + 2];
					final Stmt b = (Stmt) _symbol_b.value;
					final Symbol _symbol_a = _symbols[offset + 5];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new DoWhile(b, a));
				}
			},
			new Action() {	// [65] stmt = FOR LPAREN exprs.a SEMICOLON exprs.b SEMICOLON exprs.c RPAREN stmt.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 3];
					final ArrayList _list_a = (ArrayList) _symbol_a.value;
					final Expr[] a = _list_a == null ? new Expr[0] : (Expr[]) _list_a.toArray(new Expr[_list_a.size()]);
					final Symbol _symbol_b = _symbols[offset + 5];
					final ArrayList _list_b = (ArrayList) _symbol_b.value;
					final Expr[] b = _list_b == null ? new Expr[0] : (Expr[]) _list_b.toArray(new Expr[_list_b.size()]);
					final Symbol _symbol_c = _symbols[offset + 7];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final Expr[] c = _list_c == null ? new Expr[0] : (Expr[]) _list_c.toArray(new Expr[_list_c.size()]);
					final Symbol _symbol_p = _symbols[offset + 9];
					final Stmt p = (Stmt) _symbol_p.value;
					 return s(new For(a, b, c, p));
				}
			},
			new Action() {	// [66] stmt = FOR LPAREN type.t vars.vs SEMICOLON exprs.b SEMICOLON exprs.c RPAREN stmt.p
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_vs = _symbols[offset + 4];
					final ArrayList _list_vs = (ArrayList) _symbol_vs.value;
					final VarSpec[] vs = _list_vs == null ? new VarSpec[0] : (VarSpec[]) _list_vs.toArray(new VarSpec[_list_vs.size()]);
					final Symbol _symbol_b = _symbols[offset + 6];
					final ArrayList _list_b = (ArrayList) _symbol_b.value;
					final Expr[] b = _list_b == null ? new Expr[0] : (Expr[]) _list_b.toArray(new Expr[_list_b.size()]);
					final Symbol _symbol_c = _symbols[offset + 8];
					final ArrayList _list_c = (ArrayList) _symbol_c.value;
					final Expr[] c = _list_c == null ? new Expr[0] : (Expr[]) _list_c.toArray(new Expr[_list_c.size()]);
					final Symbol _symbol_p = _symbols[offset + 10];
					final Stmt p = (Stmt) _symbol_p.value;
					 return s(new For(Parsing.vars(t, vs), b, c, p));
				}
			},
			Action.RETURN,	// [67] expr = PREFIX
			Action.RETURN,	// [68] expr = POSTFIX
			RETURN2,	// [69] expr = LPAREN expr.e RPAREN
			new Action() {	// [70] expr = ID.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return s(new Id(n));
				}
			},
			new Action() {	// [71] expr = NUM.n
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final Integer n = (Integer) _symbol_n.value;
					 return s(new Lit(n));
				}
			},
			new Action() {	// [72] expr = STRING.s
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol s = _symbols[offset + 1];
					 return s(new Lit(s));
				}
			},
			new Action() {	// [73] expr = ID.n LPAREN RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					 return s(new FunCall(n));
				}
			},
			new Action() {	// [74] expr = ID.n LPAREN exprs.as RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_n = _symbols[offset + 1];
					final String n = (String) _symbol_n.value;
					final Symbol _symbol_as = _symbols[offset + 3];
					final ArrayList _list_as = (ArrayList) _symbol_as.value;
					final Expr[] as = _list_as == null ? new Expr[0] : (Expr[]) _list_as.toArray(new Expr[_list_as.size()]);
					 return s(new FunCall(n, as));
				}
			},
			new Action() {	// [75] expr = LPAREN type.t RPAREN expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final Type t = (Type) _symbol_t.value;
					final Symbol _symbol_a = _symbols[offset + 4];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new Cast(t, a));
				}
			},
			new Action() {	// [76] expr = SIZEOF LPAREN type.t RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 3];
					final Type t = (Type) _symbol_t.value;
					 return s(new SizeOfType(t));
				}
			},
			new Action() {	// [77] expr = SIZEOF LPAREN expr.e RPAREN
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_e = _symbols[offset + 3];
					final Expr e = (Expr) _symbol_e.value;
					 return s(new SizeOfExpr(e));
				}
			},
			new Action() {	// [78] expr = expr.a INCR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PostOp("++", a));
				}
			},
			new Action() {	// [79] expr = expr.a DECR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PostOp("--", a));
				}
			},
			new Action() {	// [80] expr = expr.a ARROW ID.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					 return s(new Arrow(a, f));
				}
			},
			new Action() {	// [81] expr = expr.a DOT ID.f
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_f = _symbols[offset + 3];
					final String f = (String) _symbol_f.value;
					 return s(new Dot(a, f));
				}
			},
			new Action() {	// [82] expr = expr.a LBRACK expr.i RBRACK
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_i = _symbols[offset + 3];
					final Expr i = (Expr) _symbol_i.value;
					 return s(new Index(a, i));
				}
			},
			new Action() {	// [83] expr = INCR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("++", a));
				}
			},
			new Action() {	// [84] expr = DECR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("--", a));
				}
			},
			new Action() {	// [85] expr = PLUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("+", a));
				}
			},
			new Action() {	// [86] expr = MINUS expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("-", a));
				}
			},
			new Action() {	// [87] expr = BANG expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("!", a));
				}
			},
			new Action() {	// [88] expr = TILDE expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("~", a));
				}
			},
			new Action() {	// [89] expr = STAR expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("*", a));
				}
			},
			new Action() {	// [90] expr = AMP expr.a
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 2];
					final Expr a = (Expr) _symbol_a.value;
					 return s(new PreOp("&", a));
				}
			},
			new Action() {	// [91] expr = expr.a STAR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("*", a, b));
				}
			},
			new Action() {	// [92] expr = expr.a DIV expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("/", a, b));
				}
			},
			new Action() {	// [93] expr = expr.a MOD expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("%", a, b));
				}
			},
			new Action() {	// [94] expr = expr.a PLUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("+", a, b));
				}
			},
			new Action() {	// [95] expr = expr.a MINUS expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("-", a, b));
				}
			},
			new Action() {	// [96] expr = expr.a SHL expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("<<",a, b));
				}
			},
			new Action() {	// [97] expr = expr.a SHR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp(">>",a, b));
				}
			},
			new Action() {	// [98] expr = expr.a LT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("<", a, b));
				}
			},
			new Action() {	// [99] expr = expr.a LE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("<=",a, b));
				}
			},
			new Action() {	// [100] expr = expr.a GE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp(">=",a, b));
				}
			},
			new Action() {	// [101] expr = expr.a GT expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp(">", a, b));
				}
			},
			new Action() {	// [102] expr = expr.a EQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("==",a, b));
				}
			},
			new Action() {	// [103] expr = expr.a NEQ expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("!=",a, b));
				}
			},
			new Action() {	// [104] expr = expr.a AMP expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("&", a, b));
				}
			},
			new Action() {	// [105] expr = expr.a CARET expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("^", a, b));
				}
			},
			new Action() {	// [106] expr = expr.a PIPE expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("|", a, b));
				}
			},
			new Action() {	// [107] expr = expr.a AND expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("&&",a, b));
				}
			},
			new Action() {	// [108] expr = expr.a OR expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("||",a, b));
				}
			},
			new Action() {	// [109] expr = expr.a QUESTION expr.b COLON expr.c
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					final Symbol _symbol_c = _symbols[offset + 5];
					final Expr c = (Expr) _symbol_c.value;
					 return s(new Question(a, b, c));
				}
			},
			new Action() {	// [110] expr = expr.a ASG expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("=", a, b));
				}
			},
			new Action() {	// [111] expr = expr.a ASG_OP.e expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_e = _symbols[offset + 2];
					final String e = (String) _symbol_e.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp("=", a, new BinOp(e.substring(0, e.length() - 1), a, b)));
				}
			},
			new Action() {	// [112] expr = expr.a COMMA expr.b
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_a = _symbols[offset + 1];
					final Expr a = (Expr) _symbol_a.value;
					final Symbol _symbol_b = _symbols[offset + 3];
					final Expr b = (Expr) _symbol_b.value;
					 return s(new BinOp(",", a, b));
				}
			},
			new Action() {	// [113] type = VOID
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Type._void());
				}
			},
			new Action() {	// [114] type = BOOL
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Type._Bool());
				}
			},
			new Action() {	// [115] type = FLOAT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Type._float());
				}
			},
			new Action() {	// [116] type = DOUBLE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Type._double());
				}
			},
			Action.NONE,  	// [117] opt$SIGNED = 
			Action.RETURN,	// [118] opt$SIGNED = SIGNED
			new Action() {	// [119] type = opt$SIGNED CHAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Signed._char());
				}
			},
			new Action() {	// [120] type = opt$SIGNED SHORT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Signed._short());
				}
			},
			new Action() {	// [121] type = opt$SIGNED INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Signed._int());
				}
			},
			new Action() {	// [122] type = opt$SIGNED LONG
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Signed._long());
				}
			},
			new Action() {	// [123] type = opt$SIGNED LONGLONG
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Signed._long_long());
				}
			},
			new Action() {	// [124] type = UNSIGNED CHAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Unsigned._char());
				}
			},
			new Action() {	// [125] type = UNSIGNED SHORT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Unsigned._short());
				}
			},
			new Action() {	// [126] type = UNSIGNED
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Unsigned._int());
				}
			},
			new Action() {	// [127] type = UNSIGNED INT
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Unsigned._int());
				}
			},
			new Action() {	// [128] type = UNSIGNED LONG
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Unsigned._long());
				}
			},
			new Action() {	// [129] type = UNSIGNED LONGLONG
				public Symbol reduce(Symbol[] _symbols, int offset) {
					 return s(Unsigned._long_long());
				}
			},
			new Action() {	// [130] type = TYPE.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final String t = (String) _symbol_t.value;
					 return s(new TypedefName(t));
				}
			},
			new Action() {	// [131] type = type.t STAR
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 1];
					final Type t = (Type) _symbol_t.value;
					 return s(new PtrType(t));
				}
			},
			new Action() {	// [132] type = STRUCT ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return s(new StructName(t));
				}
			},
			new Action() {	// [133] type = UNION ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return s(new UnionName(t));
				}
			},
			new Action() {	// [134] type = ENUM ID.t
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_t = _symbols[offset + 2];
					final String t = (String) _symbol_t.value;
					 return s(new EnumName(t));
				}
			},
			new Action() {	// [135] type = STRUCT LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fs = _symbols[offset + 3];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final FieldsSpec[] fs = _list_fs == null ? new FieldsSpec[0] : (FieldsSpec[]) _list_fs.toArray(new FieldsSpec[_list_fs.size()]);
					 return s(new AnonStruct(Parsing.fields(fs)));
				}
			},
			new Action() {	// [136] type = UNION LBRACE fields.fs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_fs = _symbols[offset + 3];
					final ArrayList _list_fs = (ArrayList) _symbol_fs.value;
					final FieldsSpec[] fs = _list_fs == null ? new FieldsSpec[0] : (FieldsSpec[]) _list_fs.toArray(new FieldsSpec[_list_fs.size()]);
					 return s(new AnonUnion(Parsing.fields(fs)));
				}
			},
			new Action() {	// [137] type = ENUM LBRACE consts.cs RBRACE
				public Symbol reduce(Symbol[] _symbols, int offset) {
					final Symbol _symbol_cs = _symbols[offset + 3];
					final ArrayList _list_cs = (ArrayList) _symbol_cs.value;
					final String[] cs = _list_cs == null ? new String[0] : (String[]) _list_cs.toArray(new String[_list_cs.size()]);
					 return s(new AnonEnum(cs));
				}
			}
		};
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		return actions[rule_num].reduce(_symbols, offset);
	}
}
