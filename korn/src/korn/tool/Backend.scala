package korn.tool

import java.io.BufferedReader
import java.io.PrintStream

import korn.smt._
import korn.Main
import korn.Util
import korn.now

object Backend {
  def read(in: BufferedReader, file: String) = {
    val status = in.readLine()

    status match {
      case "sat" =>
        val model = Backend.model(in)
        Correct(model)

      case "unsat" =>
        var trace = Backend.counterexample(in)
        
        if(Main.confirm) {
          Confirm.confirm(file, trace)
        } else {
          Incorrect(trace)
        }

      case _ =>
        Unknown(status)
    }
  }

  def readWithTimeout(timeout: Int, in: BufferedReader, file: String) = {
    val unknown: Result = Unknown("timeout")
    Util.withTimeout(timeout * 1000, unknown) { read(in, file) }
  }

  def model(in: BufferedReader): Model = {
    val scanner = new Scanner(in)
    val parser = new Parser()
    val res = parser.parse(scanner)
    val model = res.asInstanceOf[Model]
    model
  }

  def counterexample(in: BufferedReader): List[(String, BigInt)] = {
    var trace: List[(String, BigInt)] = Nil
    var line = in.readLine()
    while (line != null) {
      println(line)
      val pos = line indexOf "__VERIFIER_nondet_"
      if (pos >= 0) {
        line = line drop pos
        val lp = line indexOf "("
        val rp = line indexOf ")"
        val fun = line take lp
        val res = line drop (lp + 1) take (rp - lp - 1)
        trace = (fun, BigInt(res)) :: trace
      }
      line = in.readLine()
    }
    trace
  }

  def bind[V, T](vars: Iterable[V], typing: V => T): String = {
    import korn.smt.sexpr
    sexpr(vars map { x => sexpr(x, typing(x)) })
  }

  def write(unit: korn.horn.Unit, model: Boolean, expect: Option[String], out: PrintStream) {
    import korn.smt.sexpr
    out.println(sexpr("set-logic", "HORN"))

    val benchmark = unit.file
    val time = now()

    out.println("(set-info :source |")
    out.println(s"  Benchmark: ${benchmark}")
    // out.println(s"  Date:      ${time}")
    out.println(s"  Generated by Korn ${Main.version} https://github.com/gernst/korn")
    out.println("|)")
    out.println()

    if (model) {
      out.println(sexpr("set-option", ":produce-models", "true"))
    }

    for (status <- expect) {
      out.println(sexpr("set-info", ":status", status))
    }

    out.println()

    if (unit.pointers) {
      out.println(sexpr("declare-sort", "Pointer", "1"))
      out.println()
    }

    for (pred <- unit.preds ++ unit.pres.values ++ unit.posts.values) {
      val korn.smt.Fun(name, args, _) = pred.fun
      val defn = sexpr("declare-fun", name, sexpr(args), "Bool")
      out.println(defn)
    }
    out.println()

    for (clause <- unit.clauses) {
      val korn.smt.Clause(path, head, reason) = clause
      val bound = clause.free map (_.toString)

      out.println("; " + reason)
      out.println("(assert")
      if (bound.nonEmpty)
        out.println("  (forall " + bind(bound, unit.typing))

      if (path.nonEmpty) {
        out.println(path.mkString("    (=> (and ", "\n             ", ")"))
      }

      out.print("        " + head)

      if (path.nonEmpty)
        out.print(")")

      if (bound.nonEmpty)
        out.print(")")

      out.println(")")
      out.println()
    }

    out.println(sexpr("check-sat"))

    if (model) {
      out.println(sexpr("get-model"))
    }

    out.flush()
  }

}
